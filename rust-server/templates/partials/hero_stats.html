<section class="stats-tab">
    <h2>Hero Statistics</h2>

    <table class="hero-stats-table" id="hero-stats-table">
        <thead>
            <tr>
                <th class="col-hero">Hero</th>
                <th class="col-winrate sortable sorted-desc" data-sort="winrate">Win Rate</th>
                <th class="col-matches sortable" data-sort="matches">Total Matches</th>
                <th class="col-wins sortable" data-sort="wins">Total Wins</th>
                <th class="col-pickrate sortable" data-sort="pickrate">Pick Rate</th>
            </tr>
        </thead>
        <tbody id="hero-stats-body">
            {% for hero in heroes %}
            <tr class="{% if hero.id == selected_hero_id %}selected-hero{% endif %}"
                data-winrate="{{ hero.win_rate }}"
                data-matches="{{ hero.match_count }}"
                data-wins="{{ hero.win_count }}"
                data-pickrate="{{ hero.pick_rate }}">
                <td class="col-hero">{{ hero.name }}</td>
                <td class="col-winrate {% if hero.win_rate < 0.5 %}negative{% endif %}">{{ "{:.1}"|format(hero.win_rate * 100.0) }}%</td>
                <td class="col-matches">{{ hero.match_count }}</td>
                <td class="col-wins">{{ hero.win_count }}</td>
                <td class="col-pickrate">{{ "{:.1}"|format(hero.pick_rate * 100.0) }}%</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    {% if heroes.is_empty() %}
    <p class="no-heroes">No hero data available.</p>
    {% endif %}
</section>

<script>
(function() {
    const table = document.getElementById('hero-stats-table');
    const tbody = document.getElementById('hero-stats-body');
    const headers = table.querySelectorAll('th.sortable');

    let currentSort = 'winrate';
    let sortDir = 'desc';

    // Format match and win counts with thousands separators
    document.querySelectorAll('.col-matches, .col-wins').forEach(td => {
        if (td.tagName === 'TD') {
            const num = parseInt(td.textContent);
            if (!isNaN(num)) {
                td.textContent = num.toLocaleString();
            }
        }
    });

    // Column sorting
    headers.forEach(th => {
        th.addEventListener('click', () => {
            const sort = th.dataset.sort;

            // Toggle direction if same column
            if (currentSort === sort) {
                sortDir = sortDir === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort = sort;
                sortDir = 'desc';
            }

            // Update header classes
            headers.forEach(h => {
                h.classList.remove('sorted-asc', 'sorted-desc');
            });
            th.classList.add(sortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');

            sortRows();
        });
    });

    function sortRows() {
        const rows = Array.from(tbody.querySelectorAll('tr'));

        rows.sort((a, b) => {
            let aVal, bVal;

            if (currentSort === 'winrate') {
                aVal = parseFloat(a.dataset.winrate);
                bVal = parseFloat(b.dataset.winrate);
            } else if (currentSort === 'matches') {
                aVal = parseInt(a.dataset.matches);
                bVal = parseInt(b.dataset.matches);
            } else if (currentSort === 'wins') {
                aVal = parseInt(a.dataset.wins);
                bVal = parseInt(b.dataset.wins);
            } else if (currentSort === 'pickrate') {
                aVal = parseFloat(a.dataset.pickrate);
                bVal = parseFloat(b.dataset.pickrate);
            }

            if (sortDir === 'asc') {
                return aVal - bVal;
            } else {
                return bVal - aVal;
            }
        });

        rows.forEach(row => tbody.appendChild(row));
    }
})();
</script>
